In this setup, adding a new module or feature is straightforward: one would create a new folder in **modules** (for example, a **finance/** module if the user wanted an assistant for budgeting) with its config and any specific logic. The core might need slight modification to recognize the new module, but it would largely remain unchanged, since core operations (like scheduling) are general. This modular, MVC-like approach (though not strictly MVC, it has a similar separation of concerns) has been noted to ease adding new features – exactly what we want as we plan to integrate more capabilities over time.

Logs being separate per module also mean easier debugging and audit. For example, if something odd happens with a study reminder, the user can check `study.log` to see a trace of study-related operations. Meanwhile, `work.log` might record only work tasks events. This prevents a single giant log from mixing everything, which can get confusing.

Finally, the **config.yaml** files per module allow customization. The user could, for instance, set in `work/config.yaml` that work hours are 9am–5pm (so maybe the assistant only sends work reminders during those hours), or in `study/config.yaml` list their courses so the assistant knows “Cybersecurity 101” is one of them and can categorize study tasks by course. Keeping these in each module’s folder keeps context together with configuration. Global settings (if needed) can go in a top-level config or within core (for example, global toggle for enabling the web server or not).

This structure is designed to be **clean, scalable, and clear**. Each piece of the project knows its role, and future contributors (or the future self) can navigate it without getting lost. It also mirrors a common pattern in larger projects where domain-specific “packages” live under a common project namespace, which is effectively what we have under `modules/`. This approach will facilitate the ongoing development of LISA well beyond the initial roadmap.